# 热更新方案对比

本项目提供两种热更新方案，适用于不同的场景。

## 📊 方案对比

| 特性 | 方案1：本地手动更新 | 方案2：远程自动更新 |
|------|-------------------|-------------------|
| **文档** | [热更新架构说明.md](热更新架构说明.md) | [../../热更新完整方案.md](../../热更新完整方案.md) |
| **更新方式** | 手动修改文件 → 重启程序 | 自动检测 → 自动下载 → 自动重载 |
| **服务器** | ❌ 不需要 | ✅ 需要PHP服务器 |
| **复杂度** | ⭐ 简单 | ⭐⭐⭐ 复杂 |
| **自动化** | ❌ 手动操作 | ✅ 全自动 |
| **适用场景** | 本地开发、单机部署 | 生产环境、多客户端 |
| **main.py更新** | 重启生效 | 重启生效 |
| **tasks/*.py更新** | 重启生效 | 运行中重载 |
| **配置文件更新** | 重启生效 | 立即生效 |

## 🎯 方案1：本地手动更新（推荐用于开发）

### 核心思想
```
修改文件 → 保存 → 重启程序 → 新代码生效
```

### 架构设计
```
不可热更新（打包进exe）:
  - bootstrap.py
  - facebook_dashboard.py
  - bitbrowser_api.py
  - browser_client.py

可热更新（外部文件）:
  - automation/scripts/main.py
  - automation/scripts/tasks/*.py
  - automation/scripts/脚本配置/*.json
```

### 工作原理
1. exe启动时，bootstrap.py动态加载外部的main.py
2. main.py导入tasks/*.py
3. 修改任何外部文件后，重启程序即可生效

### 优点
- ✅ **简单直接** - 不需要额外配置
- ✅ **无需服务器** - 本地文件系统即可
- ✅ **完全可控** - 手动控制更新时机
- ✅ **易于调试** - 直接修改文件，立即测试

### 缺点
- ❌ **需要重启** - 所有更新都需要重启程序
- ❌ **手动操作** - 需要手动修改文件
- ❌ **单机限制** - 不适合多客户端统一更新

### 使用场景
- ✅ 本地开发和测试
- ✅ 单机部署
- ✅ 需要完全控制更新时机
- ✅ 不需要远程管理

### 快速开始
1. 修改文件：`automation/scripts/tasks/阅读.py`
2. 保存文件
3. 重启程序
4. 新代码生效 ✓

## 🌐 方案2：远程自动更新（推荐用于生产）

### 核心思想
```
上传到服务器 → 客户端自动检测 → 自动下载 → 自动重载 → 新代码生效
```

### 架构设计
```
┌─────────────┐
│  PHP服务器   │ ← 开发者上传文件
│  - 文件存储  │
│  - 版本管理  │
└──────┬──────┘
       │ HTTPS
       ↓
┌─────────────┐
│  客户端      │
│  - 守护进程  │ ← 每5分钟检查更新
│  - 自动下载  │
│  - 模块重载  │
└─────────────┘
```

### 工作原理
1. 守护进程后台运行，每5分钟检查一次更新
2. 发现更新后自动下载文件
3. 使用importlib.reload()重载模块
4. tasks/*.py可以运行中重载，main.py需要重启

### 优点
- ✅ **全自动** - 用户无需任何操作
- ✅ **运行中更新** - tasks/*.py可以不重启更新
- ✅ **远程管理** - 可以统一推送更新
- ✅ **多客户端** - 适合多个客户端同时更新

### 缺点
- ❌ **需要服务器** - 需要搭建PHP服务器
- ❌ **复杂度高** - 需要配置服务器、API、守护进程
- ❌ **main.py限制** - main.py仍需重启才能生效

### 使用场景
- ✅ 生产环境部署
- ✅ 多个客户端需要统一更新
- ✅ 需要远程推送更新
- ✅ 希望用户无感知更新

### 快速开始
1. 部署PHP服务器（参考文档）
2. 登录管理后台
3. 上传文件
4. 发布新版本
5. 客户端自动更新 ✓

## 🤔 如何选择？

### 选择方案1（本地手动更新）如果：
- ✅ 你在本地开发和测试
- ✅ 只有一个或少数几个客户端
- ✅ 不想搭建服务器
- ✅ 可以接受重启程序
- ✅ 需要完全控制更新时机

### 选择方案2（远程自动更新）如果：
- ✅ 你有多个客户端需要统一管理
- ✅ 希望用户无感知更新
- ✅ 可以搭建PHP服务器
- ✅ 需要远程推送更新
- ✅ 希望tasks/*.py运行中更新

## 💡 推荐方案

### 开发阶段
**使用方案1（本地手动更新）**
- 简单快速
- 易于调试
- 无需额外配置

### 生产阶段
**使用方案2（远程自动更新）**
- 自动化程度高
- 用户体验好
- 便于维护

### 混合使用
**也可以两种方案结合使用：**
- 开发时使用方案1快速迭代
- 发布时使用方案2推送更新

## 📝 实际案例

### 案例1：本地开发（方案1）

**场景**：修复阅读任务的一个bug

**步骤**：
1. 打开 `automation/scripts/tasks/阅读.py`
2. 修改代码，保存
3. 重启程序
4. 测试验证

**耗时**：1分钟

### 案例2：生产环境（方案2）

**场景**：给100个客户端推送bug修复

**步骤**：
1. 登录PHP管理后台
2. 上传修复后的 `阅读.py`
3. 发布新版本
4. 等待客户端自动更新（5分钟内）

**耗时**：2分钟（客户端自动更新）

## 🔧 技术细节

### 方案1的核心代码

**bootstrap.py**（打包进exe）：
```python
def load_main(self):
    """动态加载外部的main.py"""
    main_file = os.path.join(self.scripts_dir, "main.py")
    spec = importlib.util.spec_from_file_location("automation_main", main_file)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module
```

### 方案2的核心代码

**热更新守护进程.py**：
```python
def 检查并应用更新(self):
    """检查并应用更新"""
    # 1. 获取服务器版本
    服务器版本 = 获取服务器版本()
    
    # 2. 对比本地版本
    需要更新的文件 = 找出需要更新的文件()
    
    # 3. 下载文件
    for 文件 in 需要更新的文件:
        下载文件(文件)
    
    # 4. 重载模块
    for 文件 in 需要更新的文件:
        if 文件.startswith('tasks/'):
            重载模块(文件)
```

## 📚 相关文档

### 方案1文档
- [热更新架构说明.md](热更新架构说明.md) - 完整架构说明
- [README.md](README.md) - 项目总览

### 方案2文档
- [../../热更新完整方案.md](../../热更新完整方案.md) - 完整实现方案
- [../../update_server/README.md](../../update_server/README.md) - 服务器部署说明

## ❓ 常见问题

### Q1: 可以同时使用两种方案吗？
A: 可以。开发时用方案1，生产时用方案2。

### Q2: 方案2是否完全不需要重启？
A: 不是。tasks/*.py可以运行中重载，但main.py仍需重启。

### Q3: 方案1是否支持自动更新？
A: 不支持。方案1需要手动修改文件。

### Q4: 方案2的服务器必须是PHP吗？
A: 不是。可以用任何语言实现API，PHP只是示例。

### Q5: 如何从方案1切换到方案2？
A: 按照方案2文档部署服务器，启动守护进程即可。

---

**建议**：先使用方案1熟悉系统，需要时再升级到方案2。
